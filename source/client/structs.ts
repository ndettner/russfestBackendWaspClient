// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmlib from "../wasmlib";

export class Musician {
    name : string = "";  // Name of the musician
    shop : string = "";  // Name of associated Shop

    static fromBytes(bytes: u8[]): Musician {
        let decode = new wasmlib.BytesDecoder(bytes);
        let data = new Musician();
        data.name = decode.string();
        data.shop = decode.string();
        decode.close();
        return data;
    }

    bytes(): u8[] {
        return new wasmlib.BytesEncoder().
		    string(this.name).
		    string(this.shop).
            data();
    }
}

export class ImmutableMusician {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    value(): Musician {
        return Musician.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class MutableMusician {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    delete(): void {
        wasmlib.delKey(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    setValue(value: Musician): void {
        wasmlib.setBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES, value.bytes());
    }

    value(): Musician {
        return Musician.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class Product {
    musician    : string = "";  // Associated Musician
    price       : i64 = 0;  // Price of product
    stock       : i64 = 0;  // Available Stock
    productType : string = "";  // type of Product e.g. Tshirt

    static fromBytes(bytes: u8[]): Product {
        let decode = new wasmlib.BytesDecoder(bytes);
        let data = new Product();
        data.musician    = decode.string();
        data.price       = decode.int64();
        data.stock       = decode.int64();
        data.productType = decode.string();
        decode.close();
        return data;
    }

    bytes(): u8[] {
        return new wasmlib.BytesEncoder().
		    string(this.musician).
		    int64(this.price).
		    int64(this.stock).
		    string(this.productType).
            data();
    }
}

export class ImmutableProduct {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    value(): Product {
        return Product.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class MutableProduct {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    delete(): void {
        wasmlib.delKey(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    setValue(value: Product): void {
        wasmlib.setBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES, value.bytes());
    }

    value(): Product {
        return Product.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class ProductTemplate {
    musician    : string = "";  // Associated Musician
    price       : i64 = 0;  // Price of product
    productType : string = "";  // type of Product e.g. Tshirt
    shopName    : string = "";  // name of the Shop

    static fromBytes(bytes: u8[]): ProductTemplate {
        let decode = new wasmlib.BytesDecoder(bytes);
        let data = new ProductTemplate();
        data.musician    = decode.string();
        data.price       = decode.int64();
        data.productType = decode.string();
        data.shopName    = decode.string();
        decode.close();
        return data;
    }

    bytes(): u8[] {
        return new wasmlib.BytesEncoder().
		    string(this.musician).
		    int64(this.price).
		    string(this.productType).
		    string(this.shopName).
            data();
    }
}

export class ImmutableProductTemplate {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    value(): ProductTemplate {
        return ProductTemplate.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class MutableProductTemplate {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    delete(): void {
        wasmlib.delKey(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    setValue(value: ProductTemplate): void {
        wasmlib.setBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES, value.bytes());
    }

    value(): ProductTemplate {
        return ProductTemplate.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class Shop {
    sCAddress    : wasmlib.ScAgentID = new wasmlib.ScAgentID();  // SCs of the Shop
    fee          : i64 = 0;  // Fee the Shop wants to pay
    isRegistered : string = "";  // Sets if Shop is registered or still has open request
    musicianName : string = "";  // Name of the musician
    shopHname    : wasmlib.ScHname = new wasmlib.ScHname(0);  // hName of Shop
    shopName     : string = "";  // Name of the Shop
    shopOwner    : wasmlib.ScAgentID = new wasmlib.ScAgentID();  // Address of ShopOwner

    static fromBytes(bytes: u8[]): Shop {
        let decode = new wasmlib.BytesDecoder(bytes);
        let data = new Shop();
        data.sCAddress    = decode.agentID();
        data.fee          = decode.int64();
        data.isRegistered = decode.string();
        data.musicianName = decode.string();
        data.shopHname    = decode.hname();
        data.shopName     = decode.string();
        data.shopOwner    = decode.agentID();
        decode.close();
        return data;
    }

    bytes(): u8[] {
        return new wasmlib.BytesEncoder().
		    agentID(this.sCAddress).
		    int64(this.fee).
		    string(this.isRegistered).
		    string(this.musicianName).
		    hname(this.shopHname).
		    string(this.shopName).
		    agentID(this.shopOwner).
            data();
    }
}

export class ImmutableShop {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    value(): Shop {
        return Shop.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class MutableShop {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    delete(): void {
        wasmlib.delKey(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    setValue(value: Shop): void {
        wasmlib.setBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES, value.bytes());
    }

    value(): Shop {
        return Shop.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class Timeslot {
    end      : i64 = 0;  // enddtime of Timeslot
    musician : string = "";  // name of the musician
    start    : i64 = 0;  // starttime of Timeslot

    static fromBytes(bytes: u8[]): Timeslot {
        let decode = new wasmlib.BytesDecoder(bytes);
        let data = new Timeslot();
        data.end      = decode.int64();
        data.musician = decode.string();
        data.start    = decode.int64();
        decode.close();
        return data;
    }

    bytes(): u8[] {
        return new wasmlib.BytesEncoder().
		    int64(this.end).
		    string(this.musician).
		    int64(this.start).
            data();
    }
}

export class ImmutableTimeslot {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    value(): Timeslot {
        return Timeslot.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}

export class MutableTimeslot {
    objID: i32;
    keyID: wasmlib.Key32;

    constructor(objID: i32, keyID: wasmlib.Key32) {
        this.objID = objID;
        this.keyID = keyID;
    }

    delete(): void {
        wasmlib.delKey(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    exists(): boolean {
        return wasmlib.exists(this.objID, this.keyID, wasmlib.TYPE_BYTES);
    }

    setValue(value: Timeslot): void {
        wasmlib.setBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES, value.bytes());
    }

    value(): Timeslot {
        return Timeslot.fromBytes(wasmlib.getBytes(this.objID, this.keyID, wasmlib.TYPE_BYTES));
    }
}
